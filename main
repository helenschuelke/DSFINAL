//Graph:
#include <iostream>
#include <map>
#include <unordered_map>
#include <vector>
using namespace std;


class AdjacencyList {
private:
	vector<int> inAdj;
	vector<int> outAdj;
	int key;
public:
	AdjacencyList(int val) {
		key = val;
	}
	void AddIn(int val) {
		inAdj.push_back(val);
	}
	void AddOut(int val) {
		outAdj.push_back(val);
	}
	vector<int> GetOut() {
		return outAdj;
	}
	vector<int> GetIn() {
		return inAdj;
	}
	int NumOut() {
		int out = outAdj.size();
		return out;
	}
	int NumIn() {
		int in = inAdj.size();
		return in;
	}
};

class PageRank {
private:
	int totalVertices;
	int power;
	map<int, double> rank;
	map<int, double> worth;

public:
	PageRank(int v, map<int, AdjacencyList*>& adj) {
		totalVertices = v;
		//initialize ranking
		for (int i = 1; i <= totalVertices; i++) {
			rank[i] = (1.0 / totalVertices);
		}

		//get values from AdjacencyList
		for (int i = 1; i <= totalVertices; i++) {
			AdjacencyList* access = adj[i];
			int allOut = access->NumOut();
			double value = (1.0 / allOut); //How much each value from this vertex is worth
			worth[i] = value;
		}
	}
	map<int, double> PowerIteration(int p, map<int, AdjacencyList*>& adj) {
		power = p;

		for (int i = 1; i < power; i++) {//Loops for power

			vector<double> tempRank;
			tempRank.push_back(0.0);

			for (int j = 1; j <= totalVertices; j++) {
				AdjacencyList* access = adj[j];
				vector<int> allIn = access->GetIn();
				double sum = 0.0;
				for (int m = 0; m < allIn.size(); m++) {//go through adj list at vertex j
					int temp = allIn[m]; //value in adj list
					double value = worth[temp]; //how much the value from the adj list is worth
					double mult = rank[temp]; //what factor to multiply by given value in the adj list
					double total = value * mult; //total

					sum = sum + total;
				}
				tempRank.push_back(sum);
			}

			for (int j = 1; j <= totalVertices; j++) {//update the ranks
				rank[j] = tempRank[j];
			}
			tempRank.clear();

		}



		return rank;

	}

};

vector<string> AlphabeticalOrder(int t, map<int, string> val) {
	vector<string> abc;
	abc.push_back("place holder");//for simplicity I want the vector to start at 1
	for (int i = 1; i <= t; i++) {
		abc.push_back(val[i]);
	}

	for (int i = 1; i <= t; i++) {//sorts to alphabetical order
		for (int j = i + 1; j <= t; j++) {
			if (abc[j] < abc[i]) {
				string temp = abc[j];
				abc[j] = abc[i];
				abc[i] = temp;

			}

		}
	}

	return abc;
}

int main()
{
	map <int, string> keyMap; //get string from int key
	map <string, int> backup; //get int key from string
	vector<int> vertices; //record vertices

	map<int, AdjacencyList*> adj;//record pointers to Adjacnecy List

	map<int, double> PI;//Result from power iterations where int is the key and double is the result

	int totalVertices = 0; //keep track of total vertices
	int nextKey = 1; //keep track of individual keys
	int no_of_lines, power_iterations;
	std::string from, to;

	std::cin >> no_of_lines;
	std::cin >> power_iterations;

	for (int i = 0; i < no_of_lines; i++)
	{
		std::cin >> from;
		std::cin >> to;

		//Add to key map:

		//Check to see if string is in keyMap:
		bool fromExists = false;
		bool toExists = false;

		for (int i = 1; i <= totalVertices; i++) {
			if (keyMap[i] == from) {//from is already a node
				fromExists = true;
			}
			if (keyMap[i] == to) {//to is already a node
				toExists = true;
			}
		}


		//If not, add it:
		if (fromExists == false) {
			backup[from] = nextKey;
			keyMap[nextKey] = from;
			vertices.push_back(nextKey);

			//New vertex means new adj list
			AdjacencyList* temp = new AdjacencyList(nextKey);
			adj[nextKey] = temp;

			nextKey++;
			totalVertices++;

		}

		if (toExists == false) {
			backup[to] = nextKey;
			keyMap[nextKey] = to;
			vertices.push_back(nextKey);

			//New vertex means new adj list
			AdjacencyList* temp = new AdjacencyList(nextKey);
			adj[nextKey] = temp;

			nextKey++;
			totalVertices++;

		}

		int f = backup.find(from)->second;//Grab the key associated with from
		int t = backup.find(to)->second;//Grab the key associated with to

		//Add to AdjacencyList
		AdjacencyList* addV = adj[f];
		addV->AddOut(t);

		addV = adj[t];
		addV->AddIn(f);

	}


	PageRank* graph = new PageRank(totalVertices, adj);
	PI = graph->PowerIteration(power_iterations, adj);

	vector<string> abc = AlphabeticalOrder(totalVertices, keyMap);

	for (int i = 1; i <= totalVertices; i++) {
		int t = backup.find(abc[i])->second;
		cout << abc[i] << " ";
		printf("%.2f\n", PI[t]);
	}



}
