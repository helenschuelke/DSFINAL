#include <iostream>
#include <fstream>
#include <sstream>
#include <chrono>
#include <string>
#include <vector>

using namespace std;
using highResClock = std::chrono::high_resolution_clock;
using timePoint = highResClock::time_point;

//reusing this SimpleTimer class from my programming 2 class
class SimpleTimer {
	string message;
	timePoint start;
	timePoint stop;
	std::chrono::duration<double> elapsed;

public:
	SimpleTimer(const char *msg);
	~SimpleTimer();
};

SimpleTimer::SimpleTimer(const char *msg) {
	message = msg;
	start = highResClock::now();

}
SimpleTimer::~SimpleTimer() {
	stop = highResClock::now();
	elapsed = stop - start;
	cout << message << elapsed.count() << endl;
}


class Node {

public:
	string index;
	pair<string,string> song;
	Node *left;
	Node *right;
	//default constructor
	Node() : index(""), song("",""),left(nullptr), right(nullptr) {}
	//constructor to initialize both name and ID
	Node(string x,string title, string artist) : index(x), song(title,artist), left(nullptr), right(nullptr) {}
};

class AVL {
	//initialize root
	Node* root = nullptr;

public:
	//INSERT Functions
	void insert(string number, string name, string artist);
	Node* insertNode(Node* node, string number, string name, string artist);

	//Height and Balance check
	int heightAtNode(Node* node);
	int getBalanceFactor(Node* node);
	Node* balance(Node* node);

	//ROTATIONS
	Node* rotateLeft(Node *node);
	Node* rotateRight(Node *node);
	Node* rotateLeftRight(Node *node);
	Node* rotateRightLeft(Node *node);

	//SEARCH Functions
	void searchSong(string name);
	void searchArtist(string artist);
	void preOrderSong(string name, Node* node,vector<string>& s);
	void preOrderArtist(string artist, Node* node,vector<string>& singers);

	//PRINT Functions
	void printIn();
	void printInorder(Node* node);

};

void AVL::insert(string number, string name, string artist) {
	root = insertNode(root, number, name, artist);
}

Node* AVL::insertNode(Node* node, string number, string name, string artist) {

	if (node == nullptr) {
		return new Node(number,name,artist);
	}

	//rotate and balance nodes if necessary
	if (number < node->index) {
		node->left = insertNode(node->left, number, name, artist);
		node = balance(node);
	}
	else if (number > node->index) {
		node->right = insertNode(node->right, number, name, artist);
		node = balance(node);
	}
	else {
		//index already exists so cannot insert
		return node;
	}
	return node;
}

Node* AVL::balance(Node* node) {
	int BF = getBalanceFactor(node);

	//Right Right Case == Left Rotation
	if (BF == -2 && getBalanceFactor(node->right) == -1) {
		return rotateLeft(node);
	}
	//Left Left Case == Right Rotation
	if (BF == 2 && getBalanceFactor(node->left) == 1) {
		return rotateRight(node);
	}
	if (BF == -2 && getBalanceFactor(node->right) == 1) {
		return rotateRightLeft(node);
	}
	if (BF == 2 && getBalanceFactor(node->left) == -1) {
		return rotateLeftRight(node);
	}
	//does not need any rotation return back same node
	return node;
}

//Cite https://stepik.org/submissions/1590562/299504733?unit=400654
int AVL::getBalanceFactor(Node* node) {
	if (node == nullptr)
		return 0;
	//BF = height at left - height at right
	return heightAtNode(node->left) - heightAtNode(node->right);
}

//Cite https://stepik.org/submissions/1590562/299504733?unit=400654
int AVL::heightAtNode(Node* node) {
	//return height
	if (node == nullptr)
		return 0;

	return std::max(heightAtNode(node->left),heightAtNode(node->right)) + 1;
}

//ROTATIONS
//Cite: https://stepik.org/submissions/1480367/299020677?unit=379728
Node* AVL::rotateLeft(Node *node) {
	Node* grandchild = node->right->left;
	Node* newParent = node->right;

	newParent->left = node;
	node->right = grandchild;

	return newParent;
}

//Cite: https://stepik.org/submissions/1480367/299020677?unit=379728
Node* AVL::rotateRight(Node *node) {
	Node* grandchild = node->left->right;
	Node* newParent = node->left;
	newParent->right = node;
	node->left = grandchild;

	return newParent;
}

//Cite: https://stepik.org/submissions/1480367/299020677?unit=379728
Node* AVL::rotateLeftRight(Node *node) {
	//left rotation with left node then call right rotation
	node->left = rotateLeft(node->left);
	return rotateRight(node);
}

//Cite: https://stepik.org/submissions/1480369/299057982?unit=379728
Node* AVL::rotateRightLeft(Node *node) {
	node->right = rotateRight(node->right);
	return rotateLeft(node);
}

void AVL::searchSong(string name) {

	//create vector to store the IDs of those with same name
	vector<string> s;
	preOrderSong(name,root,s);

	//no songs matched
	if (s.size() == 0) {
		cout << "No match found!" << endl;
	}
	else {
		for (int i = 0; i < s.size(); i++) {
			cout << "Here are all the artists that sing this song: " << endl;
			cout << s.at(i) << endl;
		}
	}
}

void AVL::searchArtist(string artist) {
	//create vector to store the IDs of those with same name
	vector<string> singers;
	preOrderArtist(artist,root,singers);

	//no names matched
	if (singers.size() == 0) {
		cout << "No match found!" << endl;
	}
	else {
		for (int i = 0; i < singers.size(); i++) {
			cout << "This artist sings these holiday songs: " << endl;
			cout << singers.at(i) << endl;
		}
	}
}

//Cite: Module 4 Solutions PDF 4.1b
//incorporate vector
void AVL::preOrderSong(string name, Node* node,vector<string>& s) {

	//traverse in preOrder and push_back same song titles
	if (node == nullptr) return;

	if (name.compare(node->song.first) == 0)
		s.push_back(node->song.second);
	if (node->left)
		preOrderSong(name,node->left,s);
	if (node->right)
		preOrderSong(name,node->right,s);

}

void AVL::preOrderArtist(string artist, Node* node,vector<string>& singers) {

	//traverse in preOrder and push_back same song titles
	if (node == nullptr) return;

	if (artist.compare(node->song.second) == 0)
		singers.push_back(node->song.first);
	if (node->left)
		preOrderArtist(artist,node->left,singers);
	if (node->right)
		preOrderArtist(artist,node->right,singers);

}

void AVL::printIn() {
	printInorder(root);
}
void AVL::printInorder(Node* node) {

	if (node == nullptr)
		cout << "";

	else {
		//print comma only if there is a left or right node
		if (node->left != nullptr) {
			printInorder(node->left);
		}
		cout << "Song: " << node->song.first << endl;
		cout << "Artist: " << node->song.second << endl;

		if (node->right != nullptr) {
			printInorder(node->right);
		}
	}

}



void LoadAVLFile(AVL avl);
int main() {
	AVL avl;
	{
		SimpleTimer timer("AVL Insertion: ");
		//read in the file
		//insert all the nodes
		//Node is going to have an index, pair<string,string> song, artist
		LoadAVLFile(avl);
	}



	return 0;
}

void LoadAVLFile(AVL avl) {
	ifstream inFile;
	inFile.open("avldata.csv");

	string lineFromFile;
	//header
	getline(inFile,lineFromFile);

	while (getline(inFile,lineFromFile)) {
		istringstream line(lineFromFile);
		string index;
		string title;
		string artist;

		getline(line, index, ',');
		getline(line, title, ',');
		getline(line, artist, ',');

		avl.insert(index, title, artist);
	}

}
